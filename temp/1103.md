### 객체지향

객체  < > 주체 (반댓말로 이해하면 편함!)

subject / **object**

객체, 사물, object = 주체의 시각으로 봤을때 보여지는 모든 것 

서양의 관점 - 객체의 속성에 따라서 속성이 비슷하면 객관적으로 판단할 수 있는 것으로 같은 것으로 간주함

(꽃 모양, 줄기, 잎의 모양, 꽃잎 등 모든 속성을 다 분류해서 하나라도 완전히"똑같아야만" 한 분류로 봄)

객체지향 - 그 객체의 실제적인 데이터들(속성)을 데이터타입으로 표현하면서 추상화 > 어떤 타입으로 어떻게 표현해야하는지 어색함ㅠㅠ

인스턴스를 만들면 속성을 가지고있는 그 인스턴스만 메모리에 만들어짐 ( 할당한 변수는 indirect )

메소드를 호출한다는 것 (anObject.foobar())- 인스턴스 객체에게 (누군가인 주체- 메시지를 보내는 코드가 있는 곳) 메시지를 보내서 일을 시킴(메소드에 매개변수를 주면서) 메시지를 보내는거지 함수를 호출하는게 아니다. 처리를 못하면 컴파일러가 에러를 표시해서 알려주긴 함 



#### 캡슐화

객체의 속성이 다른 곳 (인스턴스 밖에서 인스턴스에 직접 접근해서)에서 속성을 바꿀 수 있게 설계하면 안좋음 (인스턴스이름.속성 << 이렇게 바로 접근하면 좋지 않다)

객체 안에 해당 객체의 속성으 ㄹ 바꾸는 동작을 추가해서 그 동작을 실행했을때만 다른 곳에서 바뀔 수 잇도록 하느게 좋은 구조임



### 테스트

전혀 의도하지 않았던 동작이 들어와도 방어

단위(유닛)테스트  - 함수한개 만들었으면 그 함수가 잘 동작하는지 테스트하는 테스트코드도 같이 만들어야됨

내 코드를 내가 다시 리팩토링 할 수 있는 확신을 하기 위해서도 단위테스트가 필요함

테스트 코드를 모아놓으면 그 객체를 사용할 수 있는 방법도 알기좋음

BICEP

B - boundary조건. 범위

I - 역관계. 추가하는 동작이 있는거면 제거하는 동작도 체크하는게 중요함

C - 



경계조건과 CORRECT에서 R 참조- 참조가 바뀌는 경우 에러가 발생할수있으니 의존적이지 않은 코드로 ㅈㄷ짜는게 주요





