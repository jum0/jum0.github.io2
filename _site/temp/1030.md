

1. 계산 부분에 대한 코드를 줄인다. 

   1. 계산 로직에 필요한 값은 변환전 수, 변환전 단위, 변환 전 단위에 대한 베이스 유닛 비율, 변환 후 단위, 변환 후 단위에 대한 베이스유닛 비율 

   2. 변환 후 단위는 n개가 될 수 있다. 

   3. n개의 변환 후 단위를 모두 구하려면 계산로직은 n번 반복해야함

      1. 변환 전 유닛으로 어떤 단위그룹인지 판단한다. 

      2. 변환 후 유닛의 개수를 파악한다. (n개라고 가정)

         1. 변환 후 유닛에 ,가 포함되어있으면 변환후 유닛에 어레이리스트로 더 추가해아함
         2. 변환 후 유닛이 없으면 모든 딕셔너리를 돌면서 key값이 변환 후 유닛이 되게 해야함

      3. 계산은 무조건 baseUnit으로 한번 변환한다.

      4. 최종유닛으로의 계산은 n번 시행된다.

         ​

- 변환 전 유닛을 가지고 어떤 딕셔너리그룹에 있는지 판별한다. > 어떤 딕셔너리 그룹인지 리턴! 

- 어떤 딕셔너리 그룹인지 리턴받으면 해당 딕셔러니 키값을 통해서 밸류를 리턴받을때 변환 후 유닛을 통해서 접근하고 계산하면 됨

- 변환 후 유닛을 정하지 않았을때는 딕셔너리 루프를 돌면서 키 값으로 밸류를 정하고 result에 공백으로 더해가면서 프린트...

  - 생각해보니까 프린트 함수를 따로 빼지 않아도될거같음 (어차피 한줄이라… 그냥 최종 result print하는 곳에서 바로 출력하기! - 전역변수로 굳이 초기화를 안해도돼서 메모리도 더 적게 차지할듯..?) 

  - //var result = 0 - 전역변수 result 없애고 바로 프린트하기

    //목표 유닛을 안적고 모두변환한 값을 뽑아내야할때 딕셔너리 키값으로 밸류를 찾는 반복문 안에 최종계산하는 수식 넣기



#### 함수 중심 프로그래밍

함수를 타입으로 선언하거나, 인자값으로 넘기거나, 리턴값으로 받을 수도 있다.



##### 클로저

- 함수를 선언하는 방식 대신에 다른 함수의 매개변수가 될 수도 있고 다른 함수의 매개변수가 될 수도 있음 (클로저로도 마찬가지)
- 클로저는 함수를 포함하는 개념. 따라서 클로저를 이름없는 함수라고 부를 수는 없다. 
- 클로저의 캡쳐는 간접참조 개념임. > 순수한 함수가 되지 못하는 형태
- 대괄호로 캡쳐한 값을 닫아주면 해당 클로저를 선언 할 시점의 변수 '값이 복사돼서' 해당 변수를 변경하도록 코드를 못짠다 > 순수한 함수를 짤 수 있음
- map은 안의 모든 요소를 한번씩 호출해주는 반복문이라고 보면됨
- filter : 해당 조
- reduce를 하면 2차원배열이 1차원배열로  줄어듦 (n차원이 한단계 줄어든 n-1차원배열로)
- flatMap : 





의존성이 있는 함수 : 어떤 변수에 의존해서 그 변수에 따라 input에 대한 output이 달라짐 / 보통 순수한 함수의 형태를 띄기 위해 캡쳐한 변수를 참조한다. 



### 추상화

추상화가 일어난다는 것 : 차원이 낮아지거나 정보가 줄어들어야 함. 단순화. 요약. 

### 간접참조

참조를 통한 다는 것 : 한 다리 걸쳐서 건너감. 정보가 줄어들거나 하진 않고 대신 가져다 쓰면서 상황에 따라 달라질 수 있음. 

### 구조체나 클래스를 쓸때

둘의 차이점과 장단점을 잘 파악하고, 이 상황에서 어떤 객체를 쓸지에대한 본인만의 기준이 있어야함!

타입 - substring도 타입 / string도 타입 … 제너릭이 아니라서 스트링처럼 "사용"할 수 없는건가? 아니면 그 타입의 속성에 따라 참조만 하는 타입도 있는건가?_? 둘의 차이점이 뭐지?



농협

n59938

131617



스위프트 클로저 / 스트럭트

#### 계획

첫 주에 비해 너무 늘어지는 것 같음 ㅠㅠ 목표를 정해서 해야겠다

레벨 3까지 가기 목표 : 코드스쿼드 끝나는 시점까지 or 새로운 멤버십 모집 때는 레벨3부터 시작할 수 있도록.

각 미션들 : 일주일에 하나씩 끝내기  (적어도 1.5주 안에 완료)

하루에 꼭 PR하나

하루에 하나씩 꼭 스위프트 문법 / 고급개념 익히기 (매일 저녁이나 아침에 오늘 해야할 문법 개념 정해놓기)

매일매일 TIL빠짐없이 









####  11/1 꼬인 깃 해결..

임시 브랜치를 만들면 된다고 한다. (커밋을 날릴필요없이..?_?)

youth브랜치로 가서 패치/리베이스/푸시하고 

youth브랜치에서 새로운 임시 브랜치 만들기 - readme파일같은거 살짝 수정하기

수정하고 커밋 푸시 PR 머지 패치 리베이스 

step1 브랜치 PR보내기 

CS repo에서 나의 브랜치 포크 - 내 리모트저장소가 만들어짐 - 로컬로 클론

로컬에서 내 이름 브랜치로부터 step 브랜치 만들기 

step브랜치 위에서 작업후 커밋하기 

step브랜치에서 작업후 커밋된 내용 내 로컬 repo의 내 아이디브랜치로 푸시 

푸시한 브랜치(리모트의 step브랜치)에서 CS의 내 아이디브랜치로 PR

PR머지되면 (CS repo의 내 아이디브랜치의)머지된 상태를 나의 로컬의 "내 아이디"브랜치로 fetch/rebase - 패치랑 리베이스에는 어떤 차이가 있는건지 잘 모르겠음..

그러면 내 로컬의 '내 아이디'브랜치도 merge된 상태가 됨 (CS의 내 아이디브랜치처럼 최신)

내 로컬 아이디 브랜치에서 리모트의 내 아이디브랜치로 푸시푸시

모든 싱크가 다 맞는 상태.

로컬의 '내 아이디브랜치'에서 다음 스텝 브랜치를 따고 작업 시작~ 



튜플은 사용하려는 곳에서 인덱스를 정해주면됨 >> **X 튜플은 리턴하는 곳, 사용하는곳(파라미터) 두 곳에서 인덱스가 둘다 동일해야함!** 달라도 된다는건 "튜플타입의 변수- 내부파라미터"의 이름이 달라도 된다는거였음

뭐가 됐든 내(현재 함수)가 받은 것(파라미터)의, 내가 정한 인덱스. 내 scope(함수) 안에서만 쓰는 이름으로 난 사용하고 뭐가됐든 결과값을 리턴할테니까 그걸 쓸 애(another 함수)는 니가 이름 잘 붙여서 쓰렴. 난 상관없음! 



### 스트럭트/클래스

빅너드랜치 옵셔널 스트럭트 처리하기 

~~~swift
if let terrorTown = town {} //이 코드가 문제가 됨
~~~

코드가 문제가 되는 이유. town이 옵셔널 스트럭트이기때문에 terrorTown이 nil이 아니면 let으로 선언해라 라는 if let을 써서 상수로 선언해버리면, terrorTown.스트럭트속성을변경하는함수() << 로 해도 스트럭트 안의 값이 바뀌지 않는다.

옵셔널로 스트럭트를 속성으로 받는 클래스에서 그 스트럭트 인스턴스의 속성값을 변경하려고 할때는 옵셔널체이닝으로 써야지 let상수로 선언해버리면 안됨!



#### 사다리게임 step3 - todo

- 사람 이름을 쉼표(,)를 기준으로 분리하려면 String 타입에 split(separator: ",") 메소드를 활용한다. 
  - 분리해서 배열에 추가하기 (배열 사이즈대로 사다리 가로축 사이즈를 정하기)
- `let names = inputName.split(separator: ",")`
- 사용자가 입력한 이름의 숫자 만큼 사다리 가로 축을 생성한다.
- 이름 속성을 갖는 참여자 LadderPlayer struct를 작성한다. 
  - 스트럭트 - 생성자 이름 / 사용자수대로 스트럭트 인스턴스를 만들어라
- 모든 구조체는 각자 다른 스위프트 파일로 작성한다.
- 사다리 높이 속성과 참여자를 Array로 포함하는 LadderGame struct를 작성한다.
  - 이 스트럭트의 프로퍼티는 사다리 높이 & 각각의 참여자를 담고있는 어레이 (ex Array<< LadderPlayer>>) 
  - LadderGame 스트럭트 안에서 자기가 갖고있는 프로퍼티를 사용해서 사다리를 만든다



- 게임 참여자 이름을 입력받는다 - InputView
  - 문자열로 받고 쉼표에 따라 분리까지해서 속성값으로 가지고있는다.
- InputView에서 받은 사용자 어레이 / 그 어레이의 사이즈만큼 playder struct가 있어야함 
- LadderGame struct에서는 InputView에서 받은 사다리 높이의 속성과 참여자 수를 가지고 사다리를 만드를 역할을 한다 



다른 스트럭트의 속성값에 어떤 다른 곳의 스트럭트의 함수에서 리턴된 값을 부여하려면 이런식으로 하면 되지 않을까?

let input = InputView()

ladderGame.height = input.userInput() 



모든 메소드는 각각 필요한 구조체 안에 구현만 하고 어떤 값을 input으로 받을지 "따로따로 분리해서" 구현만 한다.

각각의 구조체 안에 필요한 속성이나 함수의 인자값은 메인에서 값을 넘겨주면 된다.

- inputView에서 이름을 입력받는다
- 그 이름마다 새로운 player 인스턴스가 만들어져야 한다.
  - player의 이름은 player인스턴스의 getName()같은 함수를 이용해서 접근한다.
- LadderGame에는 생성된 player인스턴스를 담는 어레이가 있다.
- LadderGame에는 inputView에서 입력받은 사다리 높이 수도 있다.
  - Array< Player> 사이즈만큼의 사다리 행과 height정보로 사다리 열 수를 가지고 사다리를 만든다.
- ​